from typing import Dict

from data_preparers.bbox_collector import BBoxCollector
from helper_modules.perpixel_average import PerPixelAverage

import numpy as np
import torch

# define DataDistiller class
class DataDistiller:
    def __init__(self, video_file: str, tracks_file: str, channels: int, dim: int, avg_imgs_dir: str, npz_filename: str, dtype=torch.uint64):
        '''
        Initializes an instance of the DataDistiller class.

        Inputs:
            video_file: a string value representing the filepath of the video which will be processed; used by the BBoxCollector class.
            tracks_file: a path to the file containing the tracks data generated by the SortFish class; used by the BBoxCollector class.
            channels: an integer value indicating the number of channels in each bbox image (should be 3 for RGB); used by the PerPixelAverage class.
            dim: an integer value indicating the width and height of each bbox image; used by the PerPixelAverage class.
            avg_imgs_dir: a string indicating the directory in which the track average images file should be stored.
            npz_filename: a string indicating the name of the .npz file in which the track average images will be stored.
            dtype: a PyTorch datatype used in defining the sum Tensor; defaults to torch.uint64, only change to another PyTorch integer type when less precision is required.
        '''

        self.__version__ = '0.1.0'
        self.video_file = video_file
        self.tracks_file = tracks_file

        self.channels = channels
        self.dim = dim
        self.dtype = dtype

        self.avg_imgs_dir = avg_imgs_dir
        self.npz_filename = npz_filename

        self.collector = BBoxCollector(self.video_file, self.tracks_file, self.dim)

    def _compute_avgs(self, bboxes: Dict) -> Dict:
        '''
        Given a dictionary with track IDs as the keys and lists of bbox images as the values, computes the average bbox image for each track ID.

        Inputs:
            bboxes: a dictionary with track IDs as keys and lists of bbox images as values; the output of the BBoxCollector.run function.

        Returns: a dictionary containing track IDs as keys and average bbox images as the values.
        '''
        avg_imgs = dict()

        for track_id, bbox_list in bboxes.items():
            track_averager = PerPixelAverage(self.channels, self.dim, self.dim)
            
            for bbox in bbox_list:
                bbox_tensor = torch.tensor(np.array(bbox), dtype=self.dtype)
                track_averager.add(bbox_tensor)

            track_avg_img = track_averager.avg()
            avg_imgs[track_id] = track_avg_img.detach().numpy()

        return avg_imgs
    
    def _save_avg_imgs(self, avg_imgs: Dict) -> None:
        '''
        Saves the computed track average bbox images into a compressed NumPy (.npz) file.

        Inputs:
            avg_imgs: a dictionary containing track IDs as keys and average bbox images as values; the output of the DataDistiller._compute_avgs function.
        
        Returns: none.
        '''

        npz_filepath = self.avg_imgs_dir + '/' + self.npz_filename + '.npz'
        np.savez_compressed(npz_filepath, {track_id:avg for track_id, avg in avg_imgs.items()})
    
    def run_distillation(self) -> bool:
        '''
        Runs the data distillation image-averaging pipeline from start to finish.

        Returns: a Boolean indicating that the data distillation process was successfully run.
        '''
        bboxes = self.collector.run()
        
        avg_imgs = self._compute_avgs(bboxes)
        self._save_avg_imgs(avg_imgs)

        return True
